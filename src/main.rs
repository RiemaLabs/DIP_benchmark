mod r1cs;

use ark_bls12_381::{Bls12_381, Fr};
use ark_ff::{PrimeField, BigInteger};
use ark_groth16::{prepare_verifying_key, Groth16};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError, Variable};
use ark_std::rand::{rngs::StdRng, SeedableRng};
use std::io::{self, ErrorKind, Error as IoError};
use std::path::{Path, PathBuf};
use ark_snark::SNARK;

use ark_circom::WitnessCalculator;
use num_bigint::BigInt as NumBigInt;
use std::str::FromStr;

// For parsing JSON inputs
use serde_json::Value as JsonValue;
use std::collections::HashMap;

// Wasmer store for WitnessCalculator
use wasmer::Store;

use std::env;
use std::time::Instant; 

struct CircuitFromR1CS {
    r1cs: r1cs::R1CS,
    witness_values: Vec<Fr>,
}

impl CircuitFromR1CS {
    fn new(
        r1cs_data: r1cs::R1CS,
        wasm_file_path: &Path,
        input_json_path: &Path,
    ) -> io::Result<Self> {
        println!("Initializing CircuitFromR1CS with witness calculation‚Ä¶");
        println!("  Using WASM file: {}", wasm_file_path.display());
        println!("  Using Input JSON file: {}", input_json_path.display());

        if !wasm_file_path.exists() {
            let error_msg = format!(
                "WASM file not found at: {}. Please ensure it is generated by `circom circuit.circom --r1cs --wasm --sym`",
                wasm_file_path.display()
            );
            eprintln!("‚ùå {}", error_msg);
            return Err(io::Error::new(ErrorKind::NotFound, error_msg));
        }

        let mut store = Store::default();
        let mut witness_calculator = WitnessCalculator::new(&mut store, wasm_file_path)
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Failed to load WASM: {:?}", e)))?;

        let inputs_json_str = std::fs::read_to_string(input_json_path)?;
        println!("  Using private inputs for witness calculation: {}", inputs_json_str);

        let parsed_inputs_map: HashMap<String, JsonValue> = serde_json::from_str(&inputs_json_str)
            .map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse inputs JSON: {}", e)))?;
        
        let mut inputs_for_calculator: Vec<(String, Vec<NumBigInt>)> = Vec::new();
        for (key, json_val_or_array) in parsed_inputs_map {
            let mut current_signal_values = Vec::new();
            if let JsonValue::Array(string_array) = json_val_or_array {
                for s_val in string_array {
                    if let JsonValue::String(s) = s_val {
                        current_signal_values.push(NumBigInt::from_str(&s).map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse NumBigInt string '{}': {}", s, e)))?);
                    } else {
                        return Err(io::Error::new(ErrorKind::InvalidInput, "Input array element not a string"));
                    }
                }
            } else if let JsonValue::String(s_val) = json_val_or_array {
                 current_signal_values.push(NumBigInt::from_str(&s_val).map_err(|e| io::Error::new(ErrorKind::InvalidInput, format!("Failed to parse NumBigInt string '{}': {}", s_val, e)))?);
            } else {
                return Err(io::Error::new(ErrorKind::InvalidInput, format!("JSON value for key '{}' is not a string or an array of strings", key)));
            }
            inputs_for_calculator.push((key, current_signal_values));
        }
        
        println!("  Parsed inputs for calculator: {:?}", inputs_for_calculator);

        let calculated_witness_bigint: Vec<NumBigInt> = witness_calculator
            .calculate_witness(&mut store, inputs_for_calculator, true) 
            .map_err(|e| io::Error::new(ErrorKind::Other, format!("Witness calculation failed (sanity check enabled): {:?}", e)))?;

        println!("  Raw witness calculated ({} values).", calculated_witness_bigint.len());

        if calculated_witness_bigint.len() != r1cs_data.num_wires() as usize {
            let error_msg = format!(
                "Witness length mismatch: expected {}, got {}",
                r1cs_data.num_wires(),
                calculated_witness_bigint.len()
            );
            eprintln!("‚ùå {}", error_msg);
            return Err(io::Error::new(ErrorKind::InvalidData, error_msg));
        }

        let witness_values_fr: Vec<Fr> = calculated_witness_bigint
            .into_iter()
            .map(|bi| {
                Fr::from_str(&bi.to_string())
                    .unwrap_or_else(|e| panic!("Failed to convert NumBigInt {} to Fr: {:?}", bi, e))
            })
            .collect();

        Ok(Self {
            r1cs: r1cs_data,
            witness_values: witness_values_fr,
        })
    }

    fn get_public_inputs(&self) -> Vec<Fr> {
        let num_pub_out = self.r1cs.num_public_outputs() as usize;
        let num_pub_in = self.r1cs.num_public_inputs() as usize;
        
        let mut public_inputs = Vec::with_capacity(num_pub_out + num_pub_in);

        // Circom witness structure: w[0] is 1, then public outputs, then public inputs
        public_inputs.extend_from_slice(&self.witness_values[1..1 + num_pub_out]);
        public_inputs.extend_from_slice(&self.witness_values[1 + num_pub_out..1 + num_pub_out + num_pub_in]);

        public_inputs
    }
}

impl ConstraintSynthesizer<Fr> for CircuitFromR1CS {
    fn generate_constraints(
        self,
        cs: ConstraintSystemRef<Fr>,
    ) -> Result<(), SynthesisError> {
        let num_total_wires = self.r1cs.num_wires() as usize;
        let num_public_circuit_outputs = self.r1cs.num_public_outputs() as usize;
        let num_public_circuit_inputs = self.r1cs.num_public_inputs() as usize;
        let num_private_vars = self.r1cs.num_private_inputs() as usize;

        let mut variables = Vec::with_capacity(num_total_wires);

        // Wire 0: Constant One
        variables.push(Variable::One);

        // Public outputs & inputs
        for i in 1..(1 + num_public_circuit_outputs + num_public_circuit_inputs) {
            let val = self.witness_values[i];
            let var = cs.new_input_variable(|| Ok(val))?;
            variables.push(var);
        }

        // Private inputs
        for i in (1 + num_public_circuit_outputs + num_public_circuit_inputs)..num_total_wires {
            let val = self.witness_values[i];
            let var = cs.new_witness_variable(|| Ok(val))?;
            variables.push(var);
        }

        for (idx, constraint) in self.r1cs.constraints().iter().enumerate() {
            let mut a_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.a_terms {
                a_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut b_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.b_terms {
                b_lc += (term.coefficient, variables[term.wire_id as usize]);
            }

            let mut c_lc = ark_relations::r1cs::LinearCombination::<Fr>::zero();
            for term in &constraint.c_terms {
                c_lc += (term.coefficient, variables[term.wire_id as usize]);
            }
            cs.enforce_constraint(a_lc, b_lc, c_lc)?;
        }
        Ok(())
    }
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 4 {
        eprintln!("Áî®Ê≥ï: {} <circuit.r1cs> <circuit.wasm> <input.json>", args[0]);
        std::process::exit(1);
    }
    
    let r1cs_file_path = PathBuf::from(&args[1]);
    let wasm_file_path = PathBuf::from(&args[2]);
    let input_json_path = PathBuf::from(&args[3]);

    println!("üìÇ Using R1CS file: {}", r1cs_file_path.display());

    let r1cs_data = r1cs::R1CS::read(&r1cs_file_path)
        .map_err(|e| { eprintln!("‚ùå Failed to read R1CS file: {}", e); e })?;
    println!("‚úÖ Parsed R1CS, constraints = {}", r1cs_data.num_constraints());

    println!("\nCreating circuit from R1CS for setup...");
    let circuit_for_setup = CircuitFromR1CS::new(r1cs_data, &wasm_file_path, &input_json_path)?;

    println!("\nRunning Groth16 setup...");
    let mut rng = StdRng::seed_from_u64(123456789);

    let params = Groth16::<Bls12_381>::generate_random_parameters_with_reduction(
        circuit_for_setup,
        &mut rng,
    )
    .map_err(|e| {
        eprintln!("‚ùå Failed to generate Groth16 parameters: {}", e);
        io::Error::new(ErrorKind::Other, format!("{}", e))
    })?;
    println!("‚úÖ Successfully generated Groth16 parameters");

    println!("\nRe-creating circuit for proving...");
    let r1cs_data2 = r1cs::R1CS::read(&r1cs_file_path)?;
    let circuit_for_proving = CircuitFromR1CS::new(r1cs_data2, &wasm_file_path, &input_json_path)?;

    let public_inputs = circuit_for_proving.get_public_inputs();
    println!("  Confirmed public inputs for proving ({} values).", public_inputs.len());

    println!("\nGenerating Groth16 proof...");
    let proof = Groth16::<Bls12_381>::prove(&params, circuit_for_proving, &mut rng)
        .map_err(|e| {
            eprintln!("‚ùå Failed to generate proof: {}", e);
            io::Error::new(ErrorKind::Other, format!("{}", e))
        })?;
    println!("‚úÖ Successfully generated proof");

    println!("\nVerifying proof locally...");
    let pvk = prepare_verifying_key(&params.vk);
    
    let start_time = Instant::now();
    let verification_result = Groth16::<Bls12_381>::verify_with_processed_vk(&pvk, &public_inputs, &proof);
    let duration = start_time.elapsed();
    println!("[BENCHMARK_RESULT] Verification Time: {:.2}ms", duration.as_secs_f64() * 1000.0);

    match verification_result {
        Ok(true) => println!("‚úÖ Proof verified successfully!"),
        Ok(false) => {
            eprintln!("‚ùå Proof verification failed!");
            return Err(io::Error::new(ErrorKind::Other, "Proof verification failed"));
        }
        Err(e) => {
            eprintln!("‚ùå Error during verification: {}", e);
            return Err(io::Error::new(ErrorKind::Other, format!("Verification error: {}", e)));
        }
    }

    println!("\nR1CS processing complete!");

    {
        use ark_ec::AffineRepr;
        use ark_serialize::{CanonicalSerialize, Compress};
        use std::fs::File;
        use std::io::Write;

        let mut stack_items: Vec<Vec<u8>> = Vec::new();

        // 4.1 Proof (A, B, C)
        let mut proof_a = Vec::new();
        proof.a.serialize_compressed(&mut proof_a).unwrap();
        stack_items.push(proof_a);

        let mut proof_b = Vec::new();
        proof.b.serialize_compressed(&mut proof_b).unwrap();
        stack_items.push(proof_b);

        let mut proof_c = Vec::new();
        proof.c.serialize_compressed(&mut proof_c).unwrap();
        stack_items.push(proof_c);

        // 4.2 Public inputs
        for pi in public_inputs.iter() {
            let mut pi_bytes = Vec::new();
            pi.serialize_compressed(&mut pi_bytes).unwrap();
            stack_items.push(pi_bytes);
        }
        
        println!("\n‚úÖ Successfully prepared data for script generation.");
    }

    Ok(())
}
